(** We give three different definitions of the type Two:

      1) Using dependent elimination and computation rules.
      2) Using simple elimination and computation rules, together with
         uniqueness and coherence laws.
      3) Using h-initiality.
**)

Require Import HoTT.

Local Open Scope path_scope.
Local Open Scope fibration_scope.

Definition TwoAlg : Type := { C : Type &  C * C }.

Definition TwoFibAlg (X : TwoAlg) : Type :=
  match X with (C;(c_0,c_1)) =>
    { E : C -> Type & E (c_0) * E (c_1) }
  end.

Definition TwoHom (X Y : TwoAlg) : Type :=
  match X, Y with (C;(c_0,c_1)), (D;(d_0,d_1)) =>
    { f : C -> D & (f c_0 = d_0) * (f c_1 = d_1) }
  end.

Definition TwoFibHom (X : TwoAlg) : forall (Y : TwoFibAlg X), Type :=
  match X with (C;(c_0,c_1)) => fun Y =>
    match Y with (E;(e_0,e_1)) =>
      { f : forall x, E x & (f c_0 = e_0) * (f c_1 = e_1) }
    end
  end.

Definition TwoCell (X Y : TwoAlg) : forall (i j : TwoHom X Y), Type :=
  match X, Y with (C;(c_0,c_1)), (D;(d_0,d_1)) => fun i j =>
    match i, j with (f;(p_0,p_1)), (g;(q_0,q_1)) =>
      TwoFibHom (C;(c_0,c_1)) (fun x => f x = g x; (p_0 @ q_0^, p_1 @ q_1^))
    end
  end.

Definition TwoFibCell (X : TwoAlg) : forall (Y : TwoFibAlg X) (i j : TwoFibHom X Y), Type :=
  match X with (C;(c_0,c_1)) => fun Y =>
    match Y with (E;(e_0,e_1)) => fun i j =>
      match i, j with (f;(p_0,p_1)), (g;(q_0,q_1)) =>
        TwoFibHom (C;(c_0,c_1)) (fun x => f x = g x; (p_0 @ q_0^, p_1 @ q_1^))
      end
    end
  end. 

Definition hasTwoRec (X : TwoAlg) : Type := forall (Y : TwoAlg), TwoHom X Y.

Definition hasTwoInd (X : TwoAlg) : Type := forall (Y : TwoFibAlg X), TwoFibHom X Y.

Definition hasTwoRecUniq (X : TwoAlg) : Type := forall (Y : TwoAlg) (i j : TwoHom X Y), i = j.

Definition hasTwoIndUniq (X : TwoAlg) : Type :=
  forall (Y : TwoFibAlg X) (i j : TwoFibHom X Y), i = j.

Definition twoHinit (X : TwoAlg) : Type := forall (Y : TwoAlg), Contr (TwoHom X Y).

Theorem twoFibHomPathSpace : forall (X : TwoAlg) (Y : TwoFibAlg X) (i j : TwoFibHom X Y),
  i = j <~> TwoFibCell X Y i j.
Proof.
intros [C [c_0 c_1]] [E [e_0 e_1]] [f [p_0 p_1]] [g [q_0 q_1]].
apply transitivity with { a : f = g & transport (fun h => (h c_0 = e_0) * (h c_1 = e_1)) a
(p_0, p_1) = (q_0, q_1) }.
  apply symmetry.
  apply (equiv_path_sigma _ i j).




admit.
  (* apply wAlgFibMapPath_eq_algFibCell'. *)
Defined.

Theorem twoPathToFibCell (X : TwoAlg) (Y : TwoFibAlg X) (i j : TwoFibHom X Y) :
  i = j -> TwoFibCell X Y i j.
Proof.
apply equiv_fun; apply twoFibHomPathSpace.
Defined.

Theorem twoFibCellToPath (X : TwoAlg) (Y : TwoFibAlg X) (i j : TwoFibHom X Y) :
  TwoFibCell X Y i j -> i = j.
Proof.
exact (twoPathToFibCell X Y i j)^-1.
Defined.

Theorem twoHomPathSpace : forall (X Y : TwoAlg) (i j : TwoHom X Y), i = j <~> TwoCell X Y i j.
Proof.
intros [C [c_0 c_1]] [D d] i j; apply (twoFibHomPathSpace (C;(c_0,c_1)) (fun _ => D; d)).
Defined.

Theorem twoPathToCell (X Y : TwoAlg) (i j : TwoHom X Y) : i = j -> TwoCell X Y i j.
Proof.
apply equiv_fun; apply twoHomPathSpace.
Defined.

Theorem twoCellToPath (X Y : TwoAlg) (i j : TwoHom X Y) : TwoCell X Y i j -> i = j.
Proof.
exact (twoPathToCell X Y i j)^-1.
Defined.

Theorem twoIndImpIndUniq : forall (X : TwoAlg), hasTwoInd X -> hasTwoIndUniq X.
Proof.
intros [C [c_0 c_1]] h [E [e_0 e_1]] [f [p_0 p_1]] [g [q_0 q_1]]; apply twoFibCellToPath; apply h.
Defined.





